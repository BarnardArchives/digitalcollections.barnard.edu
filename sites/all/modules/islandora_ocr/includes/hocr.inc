<?php

/**
 * @file
 * Defines the HOCR class which can parse HOCR files as generated by Tesseract.
 *
 * Only supports searching for words at the moment but could easily be extended
 * to support line/paragraph level searches.
 *
 * Makes the assumption that only a single page will be contained in the HOCR
 * document at a time.
 */

/**
 * HOCR class.
 */
class HOCR {

  /**
   * The HOCR file.
   * @var DOMDocument
   */
  public $doc;
  /**
   * The XPath for querying the HOCR file.
   * @var DOMXPath
   */
  public $xpath;

  /**
   * Instantiates an HOCR object from the given datastream.
   *
   * @param AbstractDatastream $datastream
   *   The datastream containing the HOCR file.
   *
   * @return HOCR
   *   An object of this class build from the given datastream.
   */
  public static function fromDatastream(AbstractDatastream $datastream) {
    $mime_detect = new MimeDetect();
    $ext = $mime_detect->getExtension($datastream->mimeType);
    $file = file_create_filename("{$datastream->parent->id}_{$datastream->id}.{$ext}", 'temporary://');
    $datastream->getContent($file);
    $hocr = new HOCR($file);
    file_unmanaged_delete($file);
    return $hocr;
  }

  /**
   * Checks if the given HOCR file is valid.
   *
   * At the moment this only checks if the version is supported but may do more
   * in the future.
   *
   * @param string $file
   *   The absolute path to the HOCR file.
   *
   * @return bool
   *   TRUE if the HOCR file is valid, FALSE otherwise.
   */
  public static function isValid($file) {
    module_load_include('inc', 'islandora_ocr', 'includes/utilities');
    if (file_exists($file)) {
      $creator = self::getCreator($file);
      if ($creator) {
        // The source was created by tesseract, for which we only support a
        // minimum version. Check that now.
        if (strrpos($creator, 'tesseract') === 0) {
          $version = str_replace(array('tesseract', ' '), '', $creator);
          return version_compare($version, islandora_ocr_required_tesseract_version()) >= 0;
        }
        return TRUE;
      }
      return FALSE;
    }
    return FALSE;
  }

  /**
   * Gets the OCR engine creator.
   *
   * @param string $file
   *   The absolute path to the HOCR file.
   *
   * @return bool|string
   *   The version if successful, FALSE otherwise.
   */
  public static function getCreator($file) {
    @$doc = simplexml_load_file($file);
    if ($doc) {
      $doc->registerXPathNamespace('ns', 'http://www.w3.org/1999/xhtml');
      $content_attributes = $doc->xpath('/ns:html/ns:head/ns:meta[@name="ocr-system"]/@content');
      $creator = (string) reset($content_attributes);
      return empty($creator) ? FALSE : $creator;
    }
    return FALSE;
  }

  /**
   * Instantiate an HOCR object.
   *
   * @param string $file
   *   The absolute path to the HOCR file.
   *
   * @throws InvalidArgumentException
   */
  public function __construct($file) {
    if (!self::isValid($file)) {
      throw new InvalidArgumentException('Attempted to instantiate the HOCR class without a valid HOCR file.');
    }
    $this->doc = new DOMDocument('1.0', 'UTF-8');
    $this->doc->load($file);
    $this->xpath = new DOMXPath($this->doc);
    $this->xpath->registerNamespace("php", "http://php.net/xpath");
    $this->xpath->registerPhpFunctions();
  }

  /**
   * Gets the dimensions for the given page.
   *
   * Almost all HOCR documents will only have one page. Page indexes start from
   * zero.
   *
   * @param int $page_number
   *   (optional) The number of page to get, defaults to 0.
   *
   * @return array
   *   An associative array:
   *   - width: The width of the page.
   *   - height: The height of the page.
   */
  public function getPageDimensions($page_number = 0) {
    $nodes = $this->findClassNodes('ocr_page');
    $pages = $this->getProperties($nodes);
    foreach ($pages as $page) {
      // For things that have page numbers set return the match. Otherwise
      // return the first page in other pages array. It's to be noted that
      // ppageno is not an explicitly required element within an ocr_page
      // element. Similarly, with the hOCR that gets generated with tesseract
      // the page number will always be 0.
      if ((isset($page['ppageno']) && $page['ppageno'] == $page_number) || !isset($page['ppageno'])) {
        return $this->getPropertyDimensions($page);
      }
    }
    return FALSE;
  }

  /**
   * Searches for given term properties defined by the terms classes.
   *
   * @param mixed $terms
   *   Either an array or string, the term or terms to search for, the options
   *   parameter will effect how the terms are interpreted.
   *   When a string is given white-space characters are interpreted as
   *   delimiters, unless solr is provided in the options.
   * @param array $options
   *   Options to modify the text selection of the search:
   *   - case_sensitive: Defaults to FALSE.
   *   - classes: The classes of elements to return, expecting one or more  of
   *     the following: 'ocr_page', 'ocr_carea', 'ocr_par', 'ocr_line',
   *     'ocrx_word'.
   *   - solr: The solr parameters from the solr query that generated the term.
   *     these will be used to parse the given terms.
   *   - match_exact_phrase: Only match the given terms if they occur in the
   *     same order.
   *
   * @return array
   *   The properties for each term and its respective classes.
   */
  public function search($terms, array $options = array()) {
    $options += array(
      'classes' => array('ocrx_word'),
      'case_sensitive' => FALSE,
      'match_exact_phrase' => TRUE,
    );
    $terms = $this->preprocessSearchTerms($terms, $options);
    $nodes = $this->findTermNodes($terms, $options);
    return $nodes ? $this->getProperties($nodes) : array();
  }

  /**
   * Preprocess the search term.
   *
   * If SOLR parameters are given as an option, use them to extract the exact
   * term as it would exist in the HOCR document.
   *
   * @param mixed $terms
   *   Either an array or string, the term or terms to search for, the options
   *   parameter will effect how the terms are interpreted.
   * @param array $options
   *   Options to modify the text selection of the search:
   *   - case_sensitive: Defaults to FALSE.
   *   - classes: The classes of elements to return, expecting one or more  of
   *     the following: 'ocr_page', 'ocr_carea', 'ocr_par', 'ocr_line',
   *     'ocrx_word'.
   *   - solr: The solr parameters from the solr query that generated the term.
   *     these will be used to parse the given terms.
   *
   * @return string
   *   The altered search term which is more likely to match a word in the HOCR
   *   ocument.
   */
  protected function preprocessSearchTerms($terms, array $options) {
    if (isset($options['solr'])) {
      $terms = is_array($terms) ? $terms : array($terms);
      return $this->solrExtractSearchTerms($terms, $options['solr']);
    }
    // String HOCR terms treat whitespace as delimiters.
    return is_string($terms) ? explode(' ', $terms) : $terms;
  }

  /**
   * Extracts the exact terms as they would exist in the HOCR document.
   *
   * The exact term is extracted by using the highlighted information used to
   * generate the result.
   *
   * @param array $solr_highlighted_fields
   *   The solr highlighted field snippets.
   * @param array $solr_params
   *   The solr parameters from the solr query that generated the term.
   *
   * @return array
   *   An array of HOCR terms.
   */
  protected function solrExtractSearchTerms(array $solr_highlighted_fields, array $solr_params) {
    $terms = array();
    $regex_pattern = $this->solrHighlightedFieldTermRegexPattern($solr_params);
    foreach ($solr_highlighted_fields as $solr_highlighted_field) {
      $mapped_terms = $this->solrMapHighlightedFieldToTerms($solr_highlighted_field, $regex_pattern);
      $terms = array_merge($terms, $mapped_terms);
    }
    return $terms;
  }

  /**
   * Maps the highlighted SOLR field to HOCR terms, using the given pattern.
   *
   * @param array $solr_highlighted_field
   *   A solr highlighted field.
   * @param string $regex_pattern
   *   The solr parameters from the solr query that generated the term.
   *
   * @return array
   *   HOCR terms.
   */
  protected function solrMapHighlightedFieldToTerms($solr_highlighted_field, $regex_pattern) {
    $terms = array();
    $matches = array();
    if (preg_match_all($regex_pattern, $solr_highlighted_field, $matches)) {
      foreach ($matches[0] as $index => $match) {
        $term = $this->solrMapHighlightedFieldRegexMatchToTerm($matches, $index);
        // String HOCR terms treat whitespace as delimiters.
        $tokens = preg_split('/\s+/', $term);
        $terms = array_merge($terms, $tokens);
      }
    }
    return $terms;
  }

  /**
   * Generates a regex pattern for extracting highlighted terms from SOLR.
   *
   * Can match multiple highlighted terms within a highlighted SOLR field.
   *
   * @param array $solr_params
   *   SOLR query parameters used to generate the highlighted SOLR field.
   *
   * @return string
   *   The regex pattern for extracting terms from the higlighted SOLR field.
   *   The pattern contains three subpatterns, the first and third match any
   *   non-whitespace characters that occur before and after the highlighted
   *   field. This is required because SOLR can ignore some characters included
   *   inside the HOCR term.
   */
  protected function solrHighlightedFieldTermRegexPattern(array $solr_params) {
    $use_fast_vector_highlighted = isset($solr_params['hl.useFastVectorHighlighter']) && $solr_params['hl.useFastVectorHighlighter'] == 'true';
    $highlighter = $use_fast_vector_highlighted ? 'tag' : 'simple';
    $hl_pre = isset($solr_params["hl.{$highlighter}.pre"]) ? $solr_params["hl.{$highlighter}.pre"] : '<em>';
    $hl_post = isset($solr_params["hl.{$highlighter}.post"]) ? $solr_params["hl.{$highlighter}.post"] : '</em>';
    $hl_pre = preg_quote($hl_pre, '/');
    $hl_post = preg_quote($hl_post, '/');
    return "/([^\s]*){$hl_pre}(.+?){$hl_post}([^\s]*)/";
  }

  /**
   * Maps the the matched highlighted SOLR field to an HOCR term.
   *
   * @see solrHighlightedFieldTermRegexPattern()
   *
   * @param array $matches
   *   The regex matches as returned by preg_match.
   *
   * @return string
   *   The HOCR term.
   */
  protected function solrMapHighlightedFieldRegexMatchToTerm(array $matches, $index) {
    return format_string('!before_pre!solr_selected_fragment!after_post', array(
        '!before_pre' => $matches[1][$index],
        '!solr_selected_fragment' => $matches[2][$index],
        '!after_post' => $matches[3][$index],
      ));
  }

  /**
   * Find instances of the given term in document.
   *
   * @param array $terms
   *   The terms to search for.
   * @param array $options
   *   Options to modify the text selection of the search:
   *   - case_sensitive: Defaults to FALSE.
   *   - classes: The classes of elements to return, expecting one or more  of
   *     the following: 'ocr_page', 'ocr_carea', 'ocr_par', 'ocr_line',
   *     'ocrx_word'.
   *   - solr: The solr parameters from the solr query that generated the term.
   *     these will be used to parse the given terms.
   *
   * @return DOMNodeList
   *   All matching elements containing the given term and classes.
   */
  protected function findTermNodes(array $terms, array $options) {
    if (!empty($terms)) {
      $term_predicate = $this->getTermQueryPredicate($terms, $options);
      if (!empty($term_predicate)) {
        $query = "//*$term_predicate";
        if (!empty($options['classes'])) {
          $class_predicate = $this->getClassQueryPredicate($options['classes']);
          $query .= "/ancestor-or-self::node(){$class_predicate}";
        }
        return $this->xpath->query($query);
      }
    }
    return array();
  }

  /**
   * Gets the text node (term) values predicate.
   *
   * @param array $terms
   *   The terms used to generate the predicate.
   * @param array $options
   *   Options to modify the text selection of the search:
   *   - case_sensitive: Defaults to FALSE.
   *   - classes: The classes of elements to return, expecting one or more  of
   *     the following: 'ocr_page', 'ocr_carea', 'ocr_par', 'ocr_line',
   *     'ocrx_word'.
   *
   * @return string
   *   A XPath predicate that limits the query by the given terms.
   */
  protected function getTermQueryPredicate(array $terms, array $options) {
    if (isset($options['match_exact_phrase']) && $options['match_exact_phrase']) {
      return $this->getTermPhraseQueryPredicate($terms, $options);
    }
    else {
      $get_term_predicate = $this->getMatchTermExpressionFunction($options);
      $terms = array_map(array($this, $get_term_predicate), $terms);
      $predicate = implode(' or ', $terms);
      return "[$predicate]";
    }
  }

  /**
   * Generates a phrase matching predicates that will only match nodes.
   *
   * Takes the form of:
   * [text() = 'term_1' and following::*[1..n][text() =
   * 'term_2..n']]/preceding::node()[1]/following::[position() <= n]
   *
   * @param array $terms
   *   The phrase, assumed to be in order phrase.
   * @param array $options
   *   Options to modify the text selection of the search:
   *   - case_sensitive: Defaults to FALSE.
   *
   * @return string
   *   The predicate that will match the given phrase.
   */
  protected function getTermPhraseQueryPredicate(array $terms, array $options) {
    $phrase_predicate = array();
    $get_term_predicate = $this->getMatchTermExpressionFunction($options);
    foreach ($terms as $i => $term) {
      $term = $this->{$get_term_predicate}($term, 'self::node()');
      $phrase_predicate[] = "following::text()[normalize-space(self::node())][$i][{$term}]";
    }
    // The first predicate acts as an anchor, which selects the first node
    // in the given phrase if all other terms in the phrase follow it in
    // the correct order.
    $phrase_predicate[0] = $this->{$get_term_predicate}($terms[0]);
    $phrase_predicate = implode(' and ', $phrase_predicate);
    $count = count($terms);
    $predicate = "[{$phrase_predicate}]";
    if ($count > 1) {
      $predicate .= "/preceding::node()[1]/following::text()[normalize-space(self::node())][position() <= {$count}]";
    }
    return $predicate;
  }

  /**
   * Get the term predicate function based on the search options.
   *
   * @param array $options
   *   Options to modify the text selection of the search:
   *   - case_sensitive: Defaults to FALSE.
   *
   * @return string
   *   The member function to use for creating term predicates.
   */
  protected function getMatchTermExpressionFunction(array $options) {
    $case_sensitive = isset($options['case_sensitive']) && $options['case_sensitive'];
    return $case_sensitive ? 'getCaseSensitiveMatchTermExpression' : 'getCaseInsensitiveMatchTermExpression';
  }

  /**
   * Generates a XPath predicate that matches the given term exactly.
   *
   * @param string $term
   *   The term to match.
   *
   * @return string
   *   The XPath predicate to match the given term exactly.
   */
  protected function getCaseSensitiveMatchTermExpression($term, $node = 'text()') {
    return "$node = '{$term}'";
  }

  /**
   * Generates a XPath predicate performs a case-insensitive match.
   *
   * @param string $term
   *   The term to match.
   *
   * @return string
   *   The XPath predicate to do a case-insensitive match on the given term.
   */
  protected function getCaseInsensitiveMatchTermExpression($term, $node = 'text()') {
    $term = mb_strtolower($term);
    return "php:functionString('mb_strtolower', $node) = '{$term}'";
  }

  /**
   * Find all nodes of a given classes.
   *
   * @param mixed $classes
   *   The class/classes of the elements to find, one or more of the following:
   *   'ocr_page', 'ocr_carea', 'ocr_par', 'ocr_line', 'ocrx_word'.
   *   If no classes are given all nodes are returned.
   */
  protected function findClassNodes($classes) {
    $class_predicate = $this->getClassQueryPredicate($classes);
    return $this->xpath->query("//node(){$class_predicate}");
  }

  /**
   * Gets the classes attribute predicate.
   *
   * @param mixed $classes
   *   The class/classes of the elements to find, one or more of the following:
   *   'ocr_page', 'ocr_carea', 'ocr_par', 'ocr_line', 'ocrx_word'.
   *   If no classes are given all nodes are returned.
   *
   * @return string
   *   A XPath predicate that limits the query by the given class attributes.
   */
  protected function getClassQueryPredicate($classes) {
    $classes = is_array($classes) ? $classes : array($classes);
    $map = function($class) {
      return "@class = '{$class}'";
    };
    $classes = array_map($map, $classes);
    $predicate = implode(' or ', $classes);
    return "[$predicate]";
  }

  /**
   * Gets the class properties for each of the given nodes.
   *
   * @param DOMNodeList $nodes
   *   An array of DOMNode elements that have a class attribute.
   *
   * @return array
   *   An array of the properities for each given node.
   *
   * @see HOCR::getClassProperties()
   */
  protected function getProperties(DOMNodeList $nodes) {
    $results = array();
    foreach ($nodes as $node) {
      $results[] = $this->getClassNodeProperties($node);
    }
    return $results;
  }

  /**
   * Gets all the defined properties for the given class element.
   *
   * Gets nothing for non class elements.
   *
   * @param DOMElement $element
   *   The element.
   *
   * @return array
   *   An associative array of properties as follows:
   *   - id: The id of the given element.
   *   - class: The class of the given element, 'ocrx_word', 'ocr_line', etc.
   *   - dir: The direction of the written text either 'ltr' or 'rtl'.
   *   - bbox: The bounding box  of the given element.
   *     - left: The left most point of the element in pixels.
   *     - top: The top most point of the element in pixels.
   *     - right: The right most point of the element in pixels.
   *     - bottom: The bottom most point of the element in pixels.
   *   - ppageno: The number of the page if the class is 'ocr_page'.
   */
  protected function getClassNodeProperties(DOMElement $element) {
    $bbox = NULL;
    if ($element->hasAttribute('title')) {
      $matches = array();
      $title = $element->getAttribute('title');
      $pattern = '/bbox ([0-9]*) ([0-9]*) ([0-9]*) ([0-9]*)/';
      if (preg_match($pattern, $title, $matches)) {
        $bbox = array(
          'left' => intval($matches[1]),
          'top' => intval($matches[2]),
          'right' => intval($matches[3]),
          'bottom' => intval($matches[4]),
        );
      }
      $pattern = '/ppageno ([0-9]*)/';
      if (preg_match($pattern, $title, $matches)) {
        $ppageno = isset($matches[1]) ? intval($matches[1]) : NULL;
      }
    }
    // Some HOCR implementations don't provide unique IDs for words. In this
    // case let's use the node path as it's guaranteed to be unique. These IDs
    // are currently not used in any of the theme layer code.
    $properties = array_filter(array(
      'id' => $element->hasAttribute('id') ? $element->getAttribute('id') : $element->getNodePath(),
      'class' => $element->hasAttribute('class') ? $element->getAttribute('class') : NULL,
      'dir' => $element->hasAttribute('dir') ? $element->getAttribute('dir') : NULL,
      'bbox' => $bbox));
    if (isset($ppageno)) {
      $properties['ppageno'] = $ppageno;
    }
    return $properties;
  }

  /**
   * Gets the dimensions of the given class node properties.
   *
   * If the properties don't contain 'bbox' then 0 is returned
   * for the dimensions.
   *
   * @return array
   *   An associative array containing the properties dimensions.
   *   - width: The width of the page.
   *   - height: The height of the page.
   */
  protected function getPropertyDimensions(array $properties) {
    $width = 0;
    $height = 0;
    if (isset($properties['bbox'])) {
      $bbox = $properties['bbox'];
      $width = $bbox['right'] - $bbox['left'];
      $height = $bbox['bottom'] - $bbox['top'];
    }
    return array('width' => $width, 'height' => $height);
  }

  /**
   * Strip the DOCTYPE declaration from the related HOCR.
   *
   * Fedora GSearch (or Java in general) does not handle (XML) entity
   * resolution gracefully by default (tries to hit w3.org to retrieve DTDs)...
   * Ideally, a functional entity resolver could be made to be used on the Java
   * side; however, this seems like it would necessitate setting up the parser
   * in a different way, which seems like a non-trivial change in GSearch.
   * Alternatively, it seems like there should be a flag to change the HOCR
   * tesseract outputs; however, reviewing the
   * @link http://code.google.com/p/tesseract-ocr/source/browse/trunk/api/baseapi.cpp#830 source code @endlink
   * reveals that it is highly unlikely that such a flag exists. Seems simpler
   * just to wipe it.
   */
  public static function stripDoctype($hocr_string) {
    // Wipe out the HTML DOCTYPE definition.
    $doctype_regex = '/<!DOCTYPE\s+html.*?>/si';

    return preg_replace($doctype_regex, '', $hocr_string);
  }

  /**
   * Strip the DOCTYPE declaration from a file containing HOCR.
   *
   * @see HOCR::stripDoctype()
   */
  public static function stripDoctypeFromFile($filename) {
    $filename = drupal_realpath($filename);
    $file = fopen($filename, 'r+');
    if ($file) {
      $stripped_content = self::stripDoctype(fread($file, filesize($filename)));
      fseek($file, 0);
      ftruncate($file, 0);
      fwrite($file, $stripped_content);
      fclose($file);
    }
  }
}
